\chapter{MC in detail}

\section{What is MC}
MC stands for MetaCasanova and is MC is a declaritive functional language.
\section{Why MC}


\section{Goal}
The goal of MC is to use higher abstractions with type safety.

\section{Basics}
We will now go through the basics of MC.
learn how the syntax works and use small code samples to explain.


\subsection{Func}
First we need to declare a function.
For this we use the keyword \emph{Func}.

\begin{lstlisting}
Func "foo" -> Bool -> Int -> Int -> Int
\end{lstlisting}

Here we see that the function \emph{foo} is declared by a String, which is the name of the function, a Boolean and three Integers.
The last parameter is the return type of the function and all the parameters between the name and the return type, are the arguments of the function.

Now let's define the function just declared.
\begin{lstlisting}
add b c -> res
---------------
foo True b c -> res
\end{lstlisting}

A function is defined by a \emph{rule} and one or more \emph{premises}.
They are separated by the \emph{bar}.
The rule stands underneath the bar and the premises above.

In this case we have one premise above the bar.

We can also have multiple function definitions, like so:
\begin{lstlisting}
add b c -> res
---------------
foo True b c -> res

mul b c -> res
---------------
foo False b c -> res
\end{lstlisting}

When this happens the rules get executed in order if the above rule failes.

Let's take for example the following function call:
\begin{lstlisting}
foo True 5 3 -> newValue
\end{lstlisting}

The first rule to be tested is the one written first in the source code, so:
\begin{lstlisting}
foo True b c -> res
\end{lstlisting}
This rule will fail, because the first argument is false and not true.
So this function definition will not be executed.

The next rule to be matched on, is:
\begin{lstlisting}
foo False b c -> res
\end{lstlisting}
And this rule will get executed because the first argument matches.
The rule will be executed and the result will be put in \emph{newValue}.

Ofcourse the other arguments passed will also need to match.

When no parameters are given, the function acts like a variable.
\begin{lstlisting}
Func "bar" -> Int
bar -> 5
\end{lstlisting}

\subsection{Data}
With \emph{Data} we can construct a new type.
\begin{lstlisting}
Data "Left"  -> string -> string | float
Data "Right" -> float  -> string | float
\end{lstlisting}
Here we create two constructors whom both go to the same type, \emph{string | float}.

Types created by \emph{Data} can also be deconstructed.
This gives the ability to get the original types from the newly created type.
It can thus be seen as an alias on type level.

\subsection{TypeFunc}
Creates a compile time function and is able to create kinds
\begin{lstlisting}
TypeFunc "bar" => * => *

a => (c * d)
(d * c) => res
---------------
bar a => res
\end{lstlisting}

\subsection{TypeAlias}

The same as Data
Constructs and Deconstructs kinds

\subsection{Module}
Defines an interface
\begin{lstlisting}
TypeFunc "MonoidAdd" => #a => Module
MonoidAdd 'a => Module {
  Func 'a -> "+" -> 'a -> 'a
  Func "identityAdd" -> 'a
}
\end{lstlisting}
