\chapter{Standard library}\label{chap:standardlibrary}
We will now look at the standard library and explain the evolution it went through during the project.

Each item will first be explained with the evolution and improvements afterwards.
When we have an idea of how it should work, the choices made during the development will be clearer.

\section{Prelude}\label{sec:standardprelude}
\emph{Prelude} contains a few definitions making basic programming easier.
The .NET \emph{System} is imported and the type \verb\Unit\ is created.

\begin{lstlisting}
import System

Data "unit" -> Unit
\end{lstlisting}

The \verb\Unit\ is used as an empty or null value.

Next we have the declaration and definition of a generic tuple and union.
Because they are generic \verb\TypeAlias\ is needed for the type manipulation.

\begin{lstlisting}
TypeAlias Type => "*" => Type => Type
'a * 'b => tuple<'a 'b>
Data 'a -> "," -> 'b -> 'a * 'b    #> 5

TypeAlias Type => "|" => Type => Type
'a | 'b => pipe<'a 'b>
Data "Left" -> 'a -> 'a | 'b       #> 5
Data "Right" -> 'b -> 'a | 'b      #> 5
\end{lstlisting}

Then a standard if-else construct is implemented.

\begin{lstlisting}
Data "then" -> Then
Data "else" -> Else

Func "if" -> Boolean^System -> Then -> 'a -> Else -> 'a -> 'a
if True^builtin then f else g -> f
if False^builtin then f else g -> g
\end{lstlisting}

The \verb\then\ and \verb\else\ \verb\Data\s are syntatic sugar and could be left out.
We have left them in to enhance the clarity of the if-else construct.

Here we see how \emph{System} of .NET is used.
The boolean of .NET can be imported as shown, however the values \verb\True\ and \verb\False\ cannot be imported.
They are built in .NET itself.
This is why these literals are built into MC as well and need to be called using \verb\builtin\.


\subsection{Match}
Next we have the \verb\match\ function.
It takes a variable, matches it on either \verb|Left| or \verb|Right| and executes the function specified.

\begin{lstlisting}
Data "with" -> With

Func "match" -> ('a | 'b) -> With -> ('a -> 'c) -> ('b -> 'c) -> 'c
\end{lstlisting}

First there some syntactic sugar created to make it clearer how \verb\match\ works.
The first argument is the union which needs to get matched.
The arguments \verb\('a -> 'c)\ and \verb\('b -> 'c)\ are the functions to be executed on a match.

In this case the two functions both take an argument from the union, the \verb\'a\ and the \verb\'c\.

Next we have the definition of \verb\match\.
This gives a definition for both cases of the match, namely the \verb\Right\ and the \verb\Left\.

\begin{lstlisting}
match (Left x) with f g -> f x
match (Right y) with f g -> g y
\end{lstlisting}

When it matches the \verb\Left\ it executes function \verb\f\ with \verb\x\ as its argument.
And when it matches the \verb\Right\ it executes function \verb\g\ with \verb\y\ as its argument.

However this does not take into account the possibility of nested pipes.
For this we have written a third definition of \verb\match\:

\begin{lstlisting}
match y with g h -> res
--------------------
match (Right y) with f (g h) -> res
\end{lstlisting}

This definition is placed above the previous defined \verb\match\ which matches on \verb\Right\.
Then there is first checked on nested pipes and when there are none the actual value is checked.

In this manner there is no possibility of skipping any nested pipes.


\subsection{List}
Then we have a generic list implementation.
For this we need to create a list that can work with types.

The list is declared with a union.
This is necessary because we need an end to the list.

\textbf{fix code?}
\begin{lstlisting}
TypeAlias "List" => Type => Unit | (Type * (List Type))
List unit => Left unit
List ('a * 'b) => Right ('a * 'b)
\end{lstlisting}

The list is created with a tuple.
An end to the list is created with a union of the list tuple and \verb\Unit\.

A list is then defined with either a unit or type.

We also need the basic operators to create lists.
This is done with \verb\::\, which takes a type and a list.
And with \verb\empty\ an empty list is created.

\textbf{fix code?}
\begin{lstlisting}
TypeAlias Type => "::" => List => List
'a :: 'b => List ('a * 'b)

TypeAlias "empty" => List
empty => List unit
\end{lstlisting}

With \verb\::\ we can specify the head and tail of a list.

But we would also like to concat lists together.
This is done with the \verb\@\ operator.

\begin{lstlisting}
Func List 'a -> "@" -> List 'a -> List 'a  #> 200
empty @ l -> l
(x :: xs) @ l -> x :: (xs @ l)
\end{lstlisting}

And when we want to apply a function to the entire list we call \verb\map\.
This executes a function and creates a new list, which it then returns.

\begin{lstlisting}
Func "map" -> List 'a -> ('a -> 'b) -> List 'b
map empty f -> empty
map (x :: xs) f -> (f x) :: (map xs)
\end{lstlisting}

When we want to find one or more elements in the list we can call \verb\filter\.
It checks the entire list using a predicate function and returns the matching elements.

\begin{lstlisting}
Func "filter" -> List 'a -> ('a -> Boolean^System) -> List 'a
filter empty p -> empty

(if p x then
  (x :: (filter xs p))
  else
  (filter xs p)) -> res
-------------------------
filter (x :: xs) p -> res
\end{lstlisting}

The programmer can specify the predicate function \verb\p\.


\subsection{Evolution of prelude}

\subsubsection{Boolean}
Boolean currently does not exist anymore as a separate part of the standard library.
Here we will see why this is the case.

Boolean was created to implement boolean logic.
After many itterations it was discarded due to the evolution of the language.

When first implementing Boolean it was part of \emph{Prelude}.

\begin{lstlisting}
Data "True" -> Boolean^System
Data "False" -> Boolean^System
\end{lstlisting}

This might seem correct at first glance, but \verb\True\ and \verb\False\ have no meaning here.
There is no way to check if a boolean value is true or false.
That is why a new notation had to be created for the boolean literals.

It was turned into a module with the literals as \verb\Func\s.

\begin{lstlisting}
import System

TypeFunc "Boolean" => Module
Boolean => Module {
  Func "True" -> Boolean^System
  Func "False" -> Boolean^System
}
\end{lstlisting}

Which could then be implemented in \emph{prelude}.

\begin{lstlisting}
boolean => Boolean {
   True -> True^builtin
   False -> False^builtin
}
\end{lstlisting}

The boolean literals could now be called using \verb\True^boolean\.
This was noticably the same as what happened inside the implementation of \verb\boolean\.
The choice was then made to call the boolean literals directly with \verb\True^builtin\, which made the boolean module obsolete.

Which brings us to the current state of the boolean literals.


\subsubsection{Match}
\emph{Match} started as a separate part of the standard library containing the \verb\match\ module.
We will now look at how it was first created and how it has evolved into \emph{prelude}.

The first iteration of the \verb\match\ module started with the import of \emph{prelude} and the declaration of \verb\match\ module.

\begin{lstlisting}
import prelude

TypeFunc "match" => Type => Module
\end{lstlisting}

So far there are no problems yet with us a module for \verb\match\.

Next we see the first part of implementation of the \verb\match\ module:
Some syntactic sugar is created and the actual function is defined which will do the matching.

\begin{lstlisting}
match ('a | 'b) => Module {
  Data "with" -> With

  TypeFunc "Head" => Type
  Head => 'a

  TypeFunc "Tail" => Type
  Tail => 'b

  Func "doMatch" -> 'c -> With -> (Head -> 'd) -> (Tail -> 'd) -> 'd
\end{lstlisting}

Now we see why the module is needed.
It was thought that the \verb\match\ module would get a separate instance for every match that was executed.

The \verb\Head\ and \verb\Tail\ are the checks to ensure the first function takes the \verb\Left\ as input and the second function takes the \verb\Right\.
As \verb\Head\ gets set to \verb\'a\ and \verb\Tail\ to \verb\'b\.

When seperate functions, like these, are needed to check the validity of another function it is better to group them together inside a module.

The definitions of \verb\doMatch\ haven't changed compared to what they are currently.

\begin{lstlisting}
  doMatch (Left x) with f g -> f x

  doMatch y with g h -> res
  --------------------
  doMatch (Right y) with f (g h) -> res

  doMatch (Right y) with f g -> g y
}
\end{lstlisting}

It became clear that \verb\Head\ and \verb\Tail\ were not necessary, because they were simply passing on type of the union.

With this removal the use of a module became obsolete, because we do not need to group a single function.
The \verb\doMatch\ function was then renamed \verb\match\ and placed inside \emph{prelude}.


\subsubsection{Recursive match}
The first itteration of match could not match nested pipes.
It could only detect a direct match.
As it only had the direct matches without the function that checks if \verb\Right\ is nested.

The solution could have been left to the programmer.
He would have to create a separate match statement for every level of nesting.
This would be quite inconvenient for the programmer.

For that reason the recursive functionality was added.

\subsubsection{List}
The first list was put together with the list monad.
This seemed the logical choice at the time, because the list monad needed a list implementation to use inside the monad.

Monads will be explained in section~\ref{sec:standardmonad} and the list monad in section~\ref{sec:standardmonadlist}.

When coming back to the list it became apparent that \verb\List\ was not only useful for the list monad.
It could be used without the monad as a regular list implementation.

The choice was then made to move it to \emph{prelude}.


\section{Number}
\emph{Number} was created to give the user a generic interface to create numbers.

However because of the import system of MC it can directly import the integer and float types with all their functions from .NET.
It can still be used for self defined number types.

\emph{Number} is built up from different modules to give the programmer the freedom to choose what their custom numbers can do.
The modules are aranged according to the mathematical way to built up numerical operators~\cite{}.

It starts with the \verb\MonoidAdd\ module.
It declares the \verb\+\ operator for the custom number.

\begin{lstlisting}
TypeFunc "MonoidAdd" => Type => Module
MonoidAdd 'a => Module {
  Func 'a -> "+" -> 'a -> 'a #> 60
  Func "identityAdd" -> 'a
}
\end{lstlisting}

This needs the identity as a base number from which the operations will work.

Next we have the \verb\GroupAdd\ module.
This inherits everything from the module \verb\MonoidAdd\ and adds the \verb\-\ operator.

\begin{lstlisting}
TypeFunc "GroupAdd" => Type => Module
GroupAdd 'a => Module {
  inherit MonoidAdd 'a
  Func 'a -> "-" -> 'a -> 'a #> 60
}
\end{lstlisting}

We do the same for multiplication and dividing.

\begin{lstlisting}
TypeFunc "MonoidMul" => Type => Module
MonoidMul 'a => Module {
  Func 'a -> "*" -> 'a -> 'a #> 70
  Func "identityMul" -> 'a
}

TypeFunc "GroupMul" => Type => Module
GroupMul 'a => Module {
  inherit MonoidMul 'a
  Func 'a -> "/" -> 'a -> 'a #> 70
}
\end{lstlisting}

Now we have declared the basic number operations of addition, substraction, multiplication and dividing.

We can combine them into a basic number like so:

\begin{lstlisting}
TypeFunc "Number" => Type => Module
Number 'a => Module {
  inherit GroupAdd 'a
  inherit GroupMul 'a
}
\end{lstlisting}

Or create a Vector without the dividing operator, because vectors cannot be divided~\cite{}.

\begin{lstlisting}
TypeFunc "Vector" => Type => Module
Vector 'a => Module {
  inherit GroupAdd 'a
  inherit MonoidMul 'a
}
\end{lstlisting}

Ofcourse all the operators still have to be defined, but that is up to the programmer.
This gives the programmer the freedom to choose what the operators do.


\subsection{Evolution of number}
During development \emph{number} was used to create integers and floats.
This was before the .NET import system was in place and it was thus needed.
Currently it is only needed for user defined number types.

The first iteration of \emph{number} was just one module with all the operators declared.
This works for the standard number types like Integer and Float.

When using it to create a vector the module will have functions which are never used, because vectors cannot be divided.

For this reason the current \emph{number} design is similiar to the mathematical way.
It costs a bit more code to set things up, but there is less overhead.


\section{Record}
With \emph{Record} we can create a list of key/value pairs which can be searched and manipulated.
The special thing about this record is that is does all the searching on compile time.
This makes the runtime code much faster.

When using records in practice we see that not everything can will be known on compile time.
Which makes a record that works on compile time useless.

The way MC fixes this is to inline the code on compile time.
In this way the code that needs to be actually executed can be optimised by the compiler after which it is executed on runtime.

Record is declared as a module and contains TypeFuncs to make it work on compile time.

\begin{lstlisting}
TypeFunc "Record" => Module
Record => Module{
  TypeFunc "Label" => String
  TypeFunc "Field" => Type
  TypeFunc "Rest" => Record
\end{lstlisting}

Here we see a the declarations which are the basis of a list of key/value pairs.
\verb\Label\ acts as the key, \verb\Field\ as the value paired with the key and \verb\Rest\ contains the rest of the record.

When there is just one pair in the record we can get that record out easily, we already have it.
But when there are multiple record entries in a record we need a function to searches through the record to find the record we want to have.
For this the \verb\get\ function was created.

\begin{lstlisting}
  TypeFunc "get" => String => Record => Record

  (if (l == label^rs) then
    rs
  else
    get l rest^rs) => res
  -----------------------
  get l rs => res
\end{lstlisting}

The \verb\get\ function takes a labels and a record.
It checks the label of the record and if it is the same it returns the current record and if not the it recursively calls itself with the rest of the record.

To manupilate these records there the \verb\set\ function was created.

\begin{lstlisting}
  TypeFunc "set" => String => Type => Record => Record
  (if (l == label^rs) then
    RecordEntry l f rs
  else
    set l f rest^rs) => res
  -------------------------
  set l f' rs => res
}
\end{lstlisting}

The \verb\set\ function takes a label, a field and a record.
The field is the new value that needs to be paired with the label.
Because MC does not allow direct manipulation of values the set function returns a new record instead of changing the value of the specified record.

With this the declaration of the record is complete.
Now we can look at how the definition of a record works.

First we need to create a record entry.
This is done with the \verb\RecordEntry\ TypeFunc.

\begin{lstlisting}
TypeFunc "RecordEntry" => String => * => Record => Record
RecordEntry label field rest => Record{
  Field => field
  Label => label
  Rest => rest
}
\end{lstlisting}

We also need to create an empty record entry so we can end the record.
This is done by the \verb\EmptyRecord\ TypeFunc.

\begin{lstlisting}
TypeFunc "EmptyRecord" => RecordEntry
EmptyRecord => RecordEntry {
  Field => Unit
  Label => Unit
  Rest => Unit
}
\end{lstlisting}

The programmer has to use \verb\EmptyRecord\ as the \verb\rest\ argument of the first record entry.
This creates an end to the record.


\subsection{Updatable record}
The current record can only be instantiated and not updated.
To expand the record to be updatable we need to add the update function.

First we declare and define a \verb\TypeFunc\ which creates a new record from the original with inherit.

\begin{lstlisting}
TypeFunc "updatableRecord" => Record => Record
updatableRecord r => Module {
   inherit r
\end{lstlisting}

The new module now contains everything of record \verb\r\.

The we declare and define the update function.

\begin{lstlisting}
  TypeFunc "update" => Record => Type => Record
  r == Empty
  --------------------
  update r dt => Empty
}
\end{lstlisting}

Only the definition of \verb\update\ which checks for an empty record can be defined.
It is the only situation in which we can be certain what the return value will be, namely \verb\Empty\.

If the record is not \verb\Empty\ we cannot know what the programmer wants to do with \verb\update\.
That is why we leave that definition of \verb\update\ up to the programmer.



\subsection{Evolution of record}


% \subsubsection{Set and get}
% \textbf{FIX THIS !!!!!!!!!!!!!!!!!!!!!!}
% With the original version of \verb\set\ and \verb\get\ the field-argument was checked to be the same type of the current value of the field.
% for this fields was needed
% because of a fault, there needs to be no checking of the field, because field con be anything, fields became obsolete.

% We also want this for the fields of the record, which is done with \verb\Fields\.

% \begin{lstlisting}
  % TypeFunc "Fields" => Type
  % Fields => (Field,Fields^Rest)
% \end{lstlisting}


\subsubsection{Cons}
During the development the idea occured that every \verb\Record\ had to have its own type signature.
Because the field can be anything, it was thought to impact the type of the \verb\Record\.

This would be a problem when trying to declare the use of a specific \verb\Record\.

This resulted in the creation of \verb\Cons\.
\verb\Cons\ would be the type signature of that perticular \verb\Record\.

It would consist of the types of the \verb\Label\, \verb\Field\ and \verb\Rest\.

\begin{lstlisting}
  TypeFunc "Cons" => Type
  Cons => (Label,Field,Rest)
\end{lstlisting}

The prime example of the need for \verb\Cons\ came when creating the \verb\updatableRecord\ function.
It would check if the new \verb\Field\ was the same as the original \verb\Field\.

It became apparent that every record is of type \verb\Record\ and that the type of \verb\Field\ had no impact on the type of the record.
\verb\Cons\ was then removed.

This also reduced the complexity of the records for the user.
Now the user can use the records without having to keep in mind which type belongs to which record.


\subsection{Apply}
Here we will see how \verb\apply\ was thought to be needed and why it is not needed.

When we have a record with alot of nested or complex datastructures that we want to update, we have to go through the entire structure to be able to call the update function.
To fix this \verb\apply\ was created.

\verb\apply\ takes a record a record and calls the update function directly, without going through the datastructure of the record.

\begin{lstlisting}
TypeFunc "apply" => Record => Type => Record
update^r dt => res
------------------
apply r dt => res
\end{lstlisting}

Here we can see that all that \verb\apply\ does, is call the update function.
When calling \verb\apply\ we go through the record to get the record we need.
This way we only have to go through the structure of the record once and not everytime the we need to call the update function of a specific record.

We can now call \verb\apply\ to call the update function indirectly, without going to the entire record.

When implementing this we discovered we needed more than one \verb\apply\ function.
This can only be done by creating seperate functions which call the \verb\apply\.
But this would negate \verb\apply\, as these functions could also directly call the specific \verb\update\.

We then put \verb\apply\ inside a module called \verb\Rule\.
\verb\Rule\ could then be called when declaring an \verb\apply\ for a record.

This seemed like the wrong direction to go.
There was only one function inside the module of \verb\Rule\, which makes having a module redundant.
The complexity and performance was also impacted by the use of a module instead of directly calling the update function.

It was decided that the \verb\Rule\ module would be disregarded.
The problem of not being able to create multiple \verb\apply\ functions is fixed by removing \verb\apply\ all together.

The programmer can create functions like \verb\apply\ fi he feels the need to.
The programmer can then choose different names for the different \verb\update\ funtions that are being called.


