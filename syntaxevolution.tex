\chapter{Syntax evolution}
Here we will look into the overal syntax changes of the language.
The changes concerning the standard library, will be discussed in chapter~\ref{chap:standardlibrary}.

\section{Generic type identifiers}
As described in section~\ref{sec:basictypeidentifiers} generic type identifiers are indicated by \verb\'\ together with a name, \verb\'a\.
The \verb\'\ is derived from the \emph{prime} notation, which indicates a derivative of the original~\cite{primesomething}.

For example when we have identifier \verb\i\, this identifier might get changed and is then indicated by \verb\i'\.
This shows that \verb\i'\ is derived from \verb\i\.

Instead of placing the \emph{prime} at the end, it is placed before the identifier name to indicate it is a generic type.

This improved the readability of the language.
It is now clear to the user when generic types are the same of different from each other.


\section{Generic kind identifiers}
Generic kind identifiers are currently unused, but it was thought to be necessary after the implementation of \verb\TypeAlias\.

When working with kinds they are always generic, as they indicate an unknown type.
That was why they were indicated by an \emph{asteriks}, \verb\*\.

When \verb\TypeAlias\ was created it became apparent that the type would be the same in some cases.
This resulted in generic kind identifiers.

The notation devised was similiar to the generic type identifiers.
Instead of the \emph{prime} the \emph{hash} was used.

\begin{lstlisting}
TypeFunc "unknownKinds" -> #a -> #b -> #a -> #c
\end{lstlisting}

Here we can see that the first and third arguments are of the same kind and the second argument and the return value are different kinds.

However this was an error in reasoning.

The fact that they are kinds means that they can be any type.
The official notation used for kinds is either \verb\Type\ or \verb\*\.

The syntax of kinds was changed to \verb\Type\.
This way the the \verb\*\ was free to be used for other things, like the tuple in section~\ref{sec:basictypefunc}.

This also improved the readability of the language.
It is now clear when a kind is used.

Because of the use of \verb\Type\ it is also instanly clear what a kind is.
This reduces the complexity of the language.


\section{Type annotations}\label{sec:syntaxtypeannotations}
Generic type annotations were created during development to lower the complexity of the parser.

We use a data declaration which creates an array.
It takes a generic type and a Integer.

Using the notation without type annotations it looks like this:

\begin{lstlisting}
Data "array" -> 'a -> Int -> Array
\end{lstlisting}

The Integer sets the lenght and the generic type will be the type the array consists of.

When this is called we can use parentheses to indicate which arguments are grouped together.

\begin{lstlisting}
array(Int 12) -> arrayOfInts
\end{lstlisting}

The Integer array is created with twelve elements.

But when we use a variable which contains the type, there is confusion what really happens.

\begin{lstlisting}
array(var 12) -> arrayOfInts
\end{lstlisting}

This could imply that \verb\var\ is a function which uses \verb\12\ as its argument and returns a type.
\verb\arrayOfInts\ is then a closure which still needs an argument which tells the lenght of the array.

We can only be sure what happens if we look at the declaration of \verb\var\.

To avoid this and clarify what happens the type annotations were created.
They are used in the data declaration, to specify the types used.

\begin{lstlisting}
Data "array" -> 'a -> Int -> Array<'a Int>
\end{lstlisting}

Types using the type annotations cannot be partial applied, because they need to know the types they contain to be declared correctly.

When this is not done a compile time error is generated.

So now when we call \verb\array\ we know that \verb\var\ must be a type.
When \verb\var\ is declared as a function which returns a type, we will have to call \verb\array\ like this:

\begin{lstlisting}
TypeFunc "var" => Int => Type

nr == 12
------------
var nr -> Int

array((var 12) 9) -> arrayOfInts
\end{lstlisting}

This also lowers the complexity of the parser.
With the use of type annotations, the parser does not have to look at \verb\var\ and what it is.

The use of the type annotations provides greater predictability to the language.
It is now always clear what happens when working with generic types.


\section{TypeAlias}
Before there was \verb|TypeAlias|, \verb|TypeFunc| was used for the same functionality.
However \verb\TypeFunc\ cannot deconstruct.

When constructing a new kind with \verb\TypeFunc\ it can not be deconstructed to its original kind.

This error was noticed when updating the monadic part of the standard library, see section~\ref{sec:standardmonad}.

\verb\Data\ could not be used as it cannot manipulate types it can only construct and deconstruct them.
That is why \verb|TypeAlias| was created.
It provides contructing and deconstructing functionality with type manipulation.

This adds expessivity and functionality to the language.
Which is especially usefull for the user when creating complex programs.


\section{Module}
\subsection{Signature}
Earlier in development \verb|Module| was called \verb|Signature|.
It performed the same functionality as \verb|Module|.

From the language creators perspective \verb|Module| creates a specific signature on compile time.
For the user it looks more like a container or class, when coming from object-oriented programming.

Because the user will be the one actually using the language, the name was changed to what it resembles to the user.
It clarifies the syntax and makes it more predictable for the user.


\subsection{Expanding}
During the development there were two ways of inheriting a module, via \verb\inherit\ and via expanding an existing module.
Expanding modules is removed from MC, because of inconsistency issues.

A \verb\Module\ could be expanded via a function.
The function takes a module as argument and expands this module by adding declarations and, optionally, definitions.

\begin{lstlisting}
TypeFunc "expandModule" => Module => Module
expandModule M => M{
  Func "modulo" -> Float -> Float

  a % 10 -> res
  ---------------
  modulo a -> res
}
\end{lstlisting}

The module \verb\M\ is opened up again and \verb\modulo\ is added.
Module \verb\M\ is then returned and contains the new function \verb\modulo\.

This would have been syntactic sugar for creating a new module which inherits from \verb\M\.
In this new module \verb\modulo\ is then added.

\begin{lstlisting}
TypeFunc "expandModule" => Module => Module
expandModule M => Module{
  inherit M

  Func "modulo" -> Float -> Float

  a % 10 -> res
  ---------------
  modulo a -> res
}
\end{lstlisting}

The expand syntax makes it look like modules are mutable, which they are not.
This makes it inconsistent with the rest of MC and the expand-syntax was removed.

By not using the expanding functionality the language becomes more coherent and in line with itself.
This makes the language friendly to the user, because there is no two ways of doing things.
It is clear how inherit works and there is no confusion possible.


% \section{priority}
% \textbf{DO THIS!!!!!!!!}
% During the development of the language priorities were needed.
% They are necessary to implement the order of operators being executed.

% For this the

% why the \verb\#>\
% there was a need for priorities
% first only implemented without associativity
% then with right, left being the default


\section{.NET libraries}
When importing and calling .NET libraries the current syntax is using the element order of .NET with \verb\^\ as divider.

\begin{lstlisting}
Func "dotNetTest" -> String
dotNetTest -> System^DateTime^Now^ToString()
\end{lstlisting}

This was not always used.
The syntax for .NET imports went through several stages.

The first implementation was the original .NET manner:

\begin{lstlisting}
dotNetTest -> System.DateTime.Now.ToString()
\end{lstlisting}

This seemed to strange considering the rest of the MC syntax.
The order of the elements was then switched.

\begin{lstlisting}
dotNetTest -> ToString().Now.DateTime.System
\end{lstlisting}

This made it more like MC but it was still out op place because of the dot used.
It also looked strange when calling a method.

In the next itteration the dot was replaced with the caret.

\begin{lstlisting}
dotNetTest -> ToString()^Now^DateTime^System
\end{lstlisting}

This seemed more in sync with the rest of MC.
The only problem was with the method calls.

That is how we arrived at the current syntax used.
The .NET order of elements is used and the \verb\^\ is used as seperator.

The current syntax is the best compromise from a user perspective.
It takes the most central elements of both syntaxes and combines them into a clear definite syntax.


\section{Builtin}
The keyword \verb\builtin\ was first called \verb\primitives\.

For the developers this was a good choice, as they indicate the primitives that needed to be built in the compiler.

For the user however this seemed confusing.
The user sees the \verb\primitives\ as types that are built into the language.

The name was changed to \verb\builtin\, to better reflect the way how the user sees them.


% \section{Data}
% why it is not called alias.


\section{Conditionals}
\subsection{Inside the conclusion}
During development we tried implementing conditionals inside the conclusion of a rule.
This could make the code more compact.

We will take the example of \verb\Func\ from section~\ref{sec:basicfunc}, and implement this.
The code is then compacted to this:

\begin{lstlisting}
add b c -> res
---------------
computeNumber True b c -> res
\end{lstlisting}

This is just as easy to read as the original.

It does make the conclusion less conclusive as there is now something happening inside the conclusion.
The conclusion is meant to show the input and output of the rule, it is not meant to tell what the function does.

That is where the premises are for.

The compiler also needed to be modified heavily.
It now needed to do computations inside the conclusion.

To keep the language and the compiler modular, a comprise was done.
Types created with \verb\Data\ and \verb\TypeAlias\ can be used as conditionals inside the conclusion.
This is possible because they act as aliases and need no computation to be checked.

Conditionals requiring computation, a comparison of values, will be done in the premises.

This is also syntactically predictable.
Especially so because the \verb\Data\ and \verb\TypeAlias\ used in conditionals, are aliases.
They could be replaced with that from which they are constructed.


\subsection{Equals}
When comparing values the \verb\==\ operator is used.
This is done to keep the the single equals sign free to be used by the programmer.

It is also immediately clear to the programmer a conditional is done.
The single \verb\=\ could be mistaken for an alias creation of value assignment.
With the double \verb\==\ there is no such confusion.
