\chapter{Test programs}
There have been two test programs written to test the language.

The first of these is a simple bouncing ball.


\section{Bouncing ball}
Bouncing ball is used as a preliminary test of the updatable records.
It will show how the updatable recordentry are used in practice.

This program bounces a ball up and down.

The ball will have two properties, velocity and position, which will implemented as records.
Both of these will then be put inside the updatable recordentry of the ball.

The update function will then add implement how the ball bounces.

First we import prelude, recordentry and the XNA framework
The Microsoft XNA library will be used for the \verb\Vector2\ it has and the Thread library will be used to call the \verb\Sleep\ function.

\begin{lstlisting}
import Microsoft^Xna^Framework
import System^Threading^Thread
import record
import prelude
\end{lstlisting}

The recordentry of the ball will be build bottom-up.
This is done because every recordentry needs to have a \verb\rest\ as an argument.

\verb\Velocity\ is created first, because it needs to be updated less.
It keeps deep searches of the recordentry to a minimum.

\begin{lstlisting}
Record "Velocity" Vector2(0.0f, 98.1f) Empty
\end{lstlisting}

Then \verb\Position\ will be created with \verb\Velocity\ as its \verb\rest\ argument.

\begin{lstlisting}
Record "Position" Vector2(100.0f, 0.0f) Velocity
\end{lstlisting}

Lastly we create the updatable recordentry \verb\Ball\.
This is done in one line by creating a recordentry entry and passing it directly as argument to \verb\updatableRecord\.
\verb\Position\ is used as \verb\rest\ argument to complete the record.

\begin{lstlisting}
UpdatableRecord (Record "Ball" unit Position) => Ball {
\end{lstlisting}

We then need to define the \verb\update\ function.

The \verb\Position\ and \verb\Velocit\ recordentry are put in a variable, so we can use them directly.
\begin{lstlisting}
  get^e "Position" Rest^e => position
  get^e "Velocity" Rest^e => velocity
\end{lstlisting}

\begin{lstlisting}
  (if ((Field^position).Y <= 500.0f) then
    ((set^e "Position"
           (Field^position +^Vector2 (Field^velocity *^Vector2 dt))
           Rest^position)
     (set^e "Velocity"
            (Field^velocity +^Vector2 (Vector2(0.0f, 98.1f) *^Vector2 dt))
            Rest^velocity))
  else
    (set^e "Position"
           Vector2((Field^position).X, 500.0f)
           -^Vector2(Field^velocity))) -> res
  --------------------------------------------
  update e dt -> res
}
\end{lstlisting}

The final step is to create the \verb\run\ function to start the program.
It will call the update function of \verb\Ball\, sleep for a set amount of time and then call itself.

\begin{lstlisting}
Func "run" -> RecordEntry -> String

update^ball ball time -> ball'
Sleep(1000)
run ball' (time +^Int 1000) -> res
---------------
run ball time -> res
\end{lstlisting}

This creates an infinite loop, so the ball will keep on bouncing.
The return will never be set as it will keep calling itself until the program stops.

% Finally we start the program by calling
% \textbf{ask guys if the last function will be automatically executed}

\section{Tron}
Tron is a more advanced program which will utilise user input.

The game tron is played with two or more players.
Each controlling a bike which leaves a trail.
The bikes can move freely within the playingfield, but cannot stop, slow down or speed up.
The trails the bikes leave behind become walls.

A bike may not hit a wall or trail, when it does it is destroyed.
The player who remains driving is the winner.

The game tron~\cite{} has been chosen because of the minimalistic graphics.
This allows us to focus on the internal workings of the game.

Tron has been split up in two three parts, bike, playfield and main.
% Tron has been split up in two four parts, bike, playfield, powerups and main.
The main file will calls all the needed parts and starts the game.
The playfield will contain all the bikes.

% The playfield will contain all the bikes and powerups.

This will keep all the parts clear and specific to their function.

The bikes and playfield will be records.
Some of the recordentry will be made updatable recordentry when necessary.

We will start by looking at the bike.


\subsection{Bike}
First we import a few things.
The XNA framework is needed for the \verb\vector2\.
The \verb\System.Windows.Input\ will be needed for the controls of the bike.
Lastly we will import recordentry and prelude.

\begin{lstlisting}
import Framework^Xna^Microsoft
import System^Windows^Input
import record
import prelude
\end{lstlisting}

The bike will need to have several things to work in the game.

A bike will need to have a recordentry which will keep track of its current position.
The position will need to be updated so we will use an updatable record.
The position recordentry will be created seperately and included in the bike later.

This is done make the definition of the bike smaller.

The \verb\RecordEntry\ is created in the premise and then passed to \verb\UpdatableRecord\.

\begin{lstlisting}
TypeFunc "PositionRecord" => String => Vector2 => Record => Record
RecordEntry label pos rest => r
--------------------------
PositionRecord label pos rest => UpdatableRecord r => Module{
\end{lstlisting}

The created record \verb\r\ will not be explicitly inherited as that happens with the \verb\UpdatableRecord\ function.
We only need to define the update function.

The update function takes a record and a tuple.
The tulpe conists of the delta time and the speed.
This is then used to calculate the new position.

A new record containing the new position is then created and returned as the result.

\begin{lstlisting}
  dts -> (dt,speed)
  Field^p +^Vector2 dt *^Vector2 speed -> newPos
  RecordEntry label^p newPos Rest^p -> res
  -----------------------------------
  update p dts -> res
}
\end{lstlisting}

Now that we have an updatable position we also need an updatable trail.
This trail changes when the bike moves.

As with \verb\PositionRecord\ an we first create a record which is then passed to \verb\UpdatableRecord\.

\begin{lstlisting}
TypeFunc "TrailRecord" => String => Vector2 => Record => Record
RecordEntry label field rest => r
----------------------------
TrailRecord label field rest => UpdatableRecord r => Module{
\end{lstlisting}

The update function only needs to create a new trail record with the original record as its \verb\Rest\.
This way the trail is a record of points.

\begin{lstlisting}
  RecordEntry label^t pos fields^t => res
  ----------------------------------
  update t pos => res
}
\end{lstlisting}

Next we need the controls for each bike.
As the bike is always moving forward we only need to steer left or right.

The two buttons used for this are placed in a record.

\begin{lstlisting}
TypeFunc "Keys" => Key => Key => Record
RecordEntry "Left" left Empty
RecordEntry "Right" right Left
------------------------------
Keys left right => res
\end{lstlisting}

Then we come to the bike itself.
It will use the \verb\Keys\, \verb\TrailRecord\ and \verb\PositionRecord\.
And with those it also uses records to store the colour, speed and a boolean to check if it has not crashed.

The bike will also be given a name to give it a unique identifier.

In the definition we will see how the bike is build with multiple records.

\begin{lstlisting}
TypeFunc "Bike" => String => Int => Keys => Vector2 => TrailRecordEntry => Record => Record
RecordEntry "Colour" rgb Empty
RecordEntry "IsAlive" True^builtin Colour
RecordEntry "Controls" keys IsAlive
RecordEntry "Speed" speed Controls
PositionRecord "Position" position Speed
RecordEntry "Trail" trail Position => field
RecordEntry label field rest => e
--------------------------------------
Bike label rgb keys speed position trail rest => UpdatableRecord e{
\end{lstlisting}

All the records are ordered according to how often it is needed.

The update function will take a bike and the delta time as argument.
It first checks if the bike is still active and returns the bike if it is dead.

\begin{lstlisting}
  (if Field^IsAlive then
\end{lstlisting}

Next the trail, position are put in variables.

\begin{lstlisting}
    get^b "Trail" Field^b => trail
    get^trail "Position" Rest^trail => position
    get^position "Speed" Rest^position => speed
\end{lstlisting}

Then the trail and position get updated.

\begin{lstlisting}
    update^TrailRecord Field^trail Field^position => newTrailRecord
    update^PositionRecord position (dt,Field^speed) -> newPos
\end{lstlisting}

A new trail record is created and lastly a new bike record is created and returned.

\begin{lstlisting}
    RecordEntry label^trail newTrailRecord newPos => newTrail
    RecordEntry Label^b newTrail Rest^b
  else
    b) -> res
  -------------------------------------
  update b dt -> res
}
\end{lstlisting}

We now have a complete bike that can be updated.


\subsubsection{Evolution}
During the development of tron the \verb\apply\ function was used to call all the update functions.
After its removal the update functions are directly called.


\subsection{Playfield}
The playfield contains a record with the bikes, the filed size and a winner.
When the winner is set it will be returned to the main function and the game will end.

First we import the XNA framework, System, record, prelude and bike.
\begin{lstlisting}
import Framework^Xna^Microsoft
import record
import prelude
import bike
\end{lstlisting}

For the bikes a separate record will be created.
This enables a dynamic number of bikes without interfering with the playfield.

\begin{lstlisting}
TypeFunc "BikeRecord" => String => Record => Record => Record
BikeRecordEntry label bikes rest => RecordEntry label bikes rest{
\end{lstlisting}

When defining the update function we need a few extra functions to make it all work.
These functions are necessary because they do recursive operations.
This would be impossible without a separate function.

The first function is \verb\checkTrails\.
It goes over through the trail of a bike and check for any collisions.
It takes a position and trail and returns a boolean.
If any collisions are detected the boolean returns false, otherwise it returns true.

First we check for any collisions with the current point in the trail.

\begin{lstlisting}
  Func "checkTrails" -> Vector2 -> Record -> Boolean
  (if ((X^Field^pos == X^Field^trail) ||
       (Y^Field^position == Y^fieldsize)) then
    False^builtin
  else
    True^builtin) -> newIsAlive
\end{lstlisting}

If there are no collisions and there are more points in the trail, \verb\checkTrails\ is recursively called.

\begin{lstlisting}
  (if (newIsALive && (Rest^trail != Unit)) then
    checkTrails pos Rest^trail
  else
    False^builtin) -> res
  -----------------------------
  checkTrails pos trail -> res
\end{lstlisting}

Next we have \verb\checkCollisions\, which calls \verb\checkTrials\ for the trail of every bike.
It takes a bike and a record of bikes.
The position of the current bike and the trail of the first bike in the record, will be passed to \verb\checkTrails\.

\begin{lstlisting}
  Func "checkCollisions" -> Record -> Record -> Record
  get^bs "Position" Field^bs -> pos
  get^Rest "Trail" Field^rst -> trail
  checktTrails pos trail -> newIsAlive
  (if newIsAlive && (Rest^trail != Unit))hen
    checkCollisions bs Rest^rst
  else
    set^bs "IsAlive" False^builtin) -> newBs
  ------------------------------------------
  checkCollisions bs rst -> newBs
\end{lstlisting}

Then we have the function which will update the \verb\IsAlive\ status of the current bike.
First it checks if the position of the bike is within the playfield.

\begin{lstlisting}
  Func "updateIsAlive" -> Record -> Vector2 -> Record
  get^bs "Position" Field^bs -> position
  (if ((X^Field^position <= 0.0) ||
       (Y^Field^position <= 0.0) ||
       (X^Field^position >= X^fieldsize) ||
       (Y^Field^position >= Y^fieldsize))
          (set^bs "IsAlive" False^builtin Rest^bs)
        else
\end{lstlisting}

If the bike is within the playing field, any collisions with its own trail and the other bikes is tested.

\begin{lstlisting}
          ((checkTrails bs (get^bs "Trail" Field^bs)
           (checkCollisions bs Rest^bs))) -> newBs
  updateIsAlive Rest^newBs fieldsize -> newBikeRecords
  ----------------------------------------------------
  updateIsAlive bs fieldsize -> updatedBikes
\end{lstlisting}

We then come to \verb\updateBikes\.
This goes through all the bikes and calls their update function.
It then returns the updated bikes.

\begin{lstlisting}
  Func "updateBikes" -> Record -> Float -> Record
  update^b b dt -> newBike
  updateBikes Rest^b dt -> newRest
  RecordEntry Label^newBike Field^newBike newRest -> res
  ------------------------------------------------------
  updateBikes b dt -> res
\begin{lstlisting}
For this we need
\begin{lstlisting}
  updateBikes Empty dt -> Empty
\begin{lstlisting}

  Field^bs -> bikeRecords
  dtfs -> (dt,fs)
  updateBikes bikeRecords dt -> newBikeRecords
  updateIsAlive newBikeRecords fs -> aliveBikeRecords
  set^bs label^bs aliveBikeRecords bs -> res
  -----------------------------------------
  update bs dt -> res
}

TypeFunc "Playfield" => String => Record => Vector2 => Record => Record
RecordEntry "Winner" Unit Empty
BikeRecordEntry (label + "bikes") bikes Winner
RecordEntry "FieldSize" size BikeRecord
-> field
-----------
Playfield label bikes size rest => RecordEntry label field rest{

  Func "checkBikeCollisions" -> Record -> Record -> Record

  -> newBikes
  ------
  checkBikeCollisions b bs -> newBikes

  Func "checkFieldCollisions" -> Playfield -> Record -> Record
  get "Position" b -> bikePosition
  get "FieldSize" p -> playfieldSize
  (if ((X.bikePosition > X.playfieldSize) ||^System
       (X.bikePosition < 0.0) ||^System
       (Y.bikePosition > Y.playfieldSize) ||^System
       (Y.bikePosition < 0.0))then
    set^b "IsAlive" False^builtin b
  else
    b) -> newBike
  --------
  checkFieldCollisions p b -> newBike

  Func "checkCollisions" -> Playfield -> Record -> Playfield
  checkFieldCollisions p b -> newBike
  (if (Rest^newBike = Empty) then
    set^p
  else
    checkBikeCollisions b Rest^b -> newNewBike
    checkCollisions p Rest^b
    ) -> newPlayfield
  ------
  checkCollisions p b -> newPlayfield

  Func "checkDeaths" -> Playfield -> Playfield

  checkDeaths p -> newP



  get^p (Label^p + "bikes") Field^p -> bikes
  update^bikes bikes dt -> newBikes
  set^p (Label^p + "bikes") newBikes Fields^p -> newPlayfield
  checkDeaths newPlayfield ->
  --------
  update p dt -> res
}
\end{lstlisting}

\subsection{Main}
\begin{lstlisting}
import playfield
import bike
import either
import state


game
  playfield

  bikeOne

  bikeTwo

Func "start" -> 'a

playfield bikeOne bikeTwo -> gamefield
play gamefield -> res
---------------------
start -> res
\end{lstlisting}

% \subsection{Powerups}
% \begin{lstlisting}
% Func "dottedLine" -> Bike -> Bike
% Func "ghostMode" -> Bike -> Bike
% Func "thickerLine" -> Bike -> Bike
% \end{lstlisting}
