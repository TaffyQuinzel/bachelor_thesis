\input{markup.tex}
%% \newenvironment{poliabstract}[1]
%%                {\renewcommand{\abstractname}{#1}\begin{abstract}}
%%                {\end{abstract}}

% start actual doc
\begin{document}
\title{Testing the Meta-Compiler language}
\author{\writer}
% \date{25 January 2016}

\begin{titlepage}
   \include{voorpaginamandate}
\end{titlepage}

%\maketitle
% state the problem
% say why it's an interesting problem
% say what your solution is
% say what follows from your solution

% \begin{abstract}
% MC has not been tested in the field yet and we want to know how it fares.
% We will put it to the test and see that it still needs some development, but has promise.
% \end{abstract}
% \newpage

\pagenumbering{gobble}
\setcounter{tocdepth}{2}
\tableofcontents
\cleardoublepage
\pagenumbering{arabic}
\addtocounter{page}{4}

% \begin{multicols}{2}
\include{mandate}
\include{planning}
part{intro}
\include{introduction}

part{background}
\include{problem}
\include{idea}

\chapter{interlude}
MC stands for MetaCasanova. The reason behind the name is explained in chapter \refchapter{MetaCasanova}.

We will first talk about what MC is and explain the basics of the language.
Then we will discuss the Standard Library of MC, which is written completely in MC.
After which we will show some practical examples.


\chapter{MetaCasanova}

\section{What is MC}
MC stands for MetaCasanova and is MC is a declaritive functional language.
\section{Why MC}


\section{Goal}
The goal of MC is to use higher abstractions with type safety.

\section{Basics}
We will now go through the basics of MC.

\subsection{Func}
First we need to declare a function.
   \begin{lstlisting}
Func "foo" -> Bool -> Int -> Int -> Int
   \end{lstlisting}
   For this we use the keyword \emph{Func}.
   Here we see that the function \emph{foo} is declared by a String, which is the name of the function, a Boolean and three Integers.
   The last parameter is the return type of the function and all the parameters between the name and the return type, are the arguments of the function.

   When no parameters are given the function becomes a variable, as seen in figure \ref{}.
   \begin{lstlisting}
Func "foo" -> Int
foo -> 5
   \end{lstlisting}

   \begin{lstlisting}
add b c -> res
---------------
foo True b c -> res

mul b c -> res
---------------
foo False b c -> res
   \end{lstlisting}

   Here we see the basic syntax for declaring and defining a function.

\subsection{Data}
\subsection{TypeFunc}
\subsection{TypeAlias}
\subsection{Module}


\chapter{standard library}
\section{BasicMonads}
\subsection{Monads}
\subsection{Monad transformers}
\subsubsection{Id}
\subsubsection{List}
\subsubsection{Either}
\subsubsection{Option}
\subsubsection{Result}
\subsubsection{State}
\subsubsection{IO}

\section{Standard Library}
\subsection{match}
\subsection{monad}
\subsection{prelude}
\subsection{number}
\subsection{record}
\subsection{tryableMonad}

\section{Casanova}
\subsection{Entity}
\subsection{Coroutines}


\chapter{test programs}
\section{bouncing ball}
\section{tron}
\subsection{bike}
\subsection{playfield}
\subsection{powerups}


\chapter{Conclusion}
\chapter{Reflection}

\part{work done}
\include{details}

part{conclusion/reflection}
\include{conclusion}

part{appendixes}
\include{related}

% \bibliographystyle{ieeetr}
% \bibliography{biblio}

% \end{multicols}{3}
\end{document}
