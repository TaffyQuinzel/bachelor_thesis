\chapter{A good programming language}\label{sec:criteria}

For a programming language to be practically usable it needs to be tested on the following criteria\cite{khedker1997makes,graham2004hackers}:

\begin{multicols}{2}
\begin{enumerate}[noitemsep]
   \item Read- \& Writability
   \item Simplicity
   \item Definiteness
   \item Predictability
   \item Expressiveness
   \item Implementability
   \item Efficiency
   \item Libraries
   \item Time
   \item Hackability
   \item Succintness
   \item Redesign
   \item External Factors
\end{enumerate}
\end{multicols}
Let's touch on each of these briefly, before we connect them to MC.

\section{Read- \& Writability }
The read- and writability of a programming language determines how good the connection between man and machine is.
The programmer must be able to write programs he understands easily, even after months or years of not looking at them.

With easy to read and write programs also comes ease of debugging.
We can quickly notice any faults in the source code.

Documentation makes up a basic part of read- \& writability.
To really be able to make a program readable, even after a long delay between writing, the language needs to be its own documentation.
This can be done in a manner of ways:
\begin{itemize}[noitemsep]
   \item Keywords
   \item Abbreviations and concise notation
   \item Comments
   \item Layout or format of programs
   \item No overuse of notation
\end{itemize}
% These points will be explained later on with examples of MC in section~\ref{somewhere}.

\section{Simplicity}
The simplicity of a language is decided by its features.
These should be easy to learn and remember.
To quantify this we will make use of these sub points:
\begin{itemize}[noitemsep]
   \item Structure
   \item Number of features
   \item Multiple ways of specification
   \item Multiple ways of expressing
\end{itemize}

% We will touch on these briefly with concern towards MC~\ref{sec:simplicity}.
The main concept through which simplicity is achieved is basing the language around a few simple well-defined concepts~\cite{khedker1997makes}.

\section{Definiteness}
Definiteness clarifies for which purpose the language is designed and how it is to be used.
When a language has a clear view and definition of itself, it will also be clear to the user for what purposes to use the language.

\section{Predictability}
Predictability makes using the language easier for the user.
When one user writes the same code as another user, the result should be the same.
This implies that if the user understands the basics of the language, he can than expand beyond them by combining these basics.

However, the rules of the language should not hinder the user by making the available combinations too complex.

\section{Expressiveness}
Expressiveness goes hand in hand with abstraction.
The user should be able to write code in a way that matches the structure in his thoughts.

Machine language is hard to understand and use for a human, it has nearly no abstraction and the programmer has to keep track of the registers by hand.
This can however be remedied by the language the user is using.
It is the link between what the user has in his mind and what the machine will execute.
Therefore the language should be similar to the way the user thinks.
This makes it easier for the user to express his thoughts in code.

\section{Efficiency}
Efficiency is something most users want out of their computer.
Programmers like to write fast programs.
The language should facilitate this.
Even if the language is very abstract, which usually means it is less efficient~\cite{graham2004hackers}, it should be able to generate fast code, or making visible to the user where the bottlenecks are.

\section{Custom libraries}
Custom libraries are a necessity for every programming language.
Without them the language would be useless and the programmer would have to build every feature from the ground up.
This makes programming in the language take much longer then necessary.

\section{Time}
Time is something everything needs to build momentum and a stable user base, even programming languages cannot escape this.
For now we will not be able to test this, as MC is still in its development stages.
For this reason we will leave this out.

\section{Hackability}
Hackability is the ability to bend the language to the will of the user or to form the language to the needs of the user.
In other words how much you can do with the language and how malleable and versatile it is.
This also depends on the ability of the programmer, namely to think outside the pre-defined box of the language.
We will try to see how well MC supports this type of thinking.

\section{Succinctness}
The succinctness makes a language more abstract.
When you have to say less to make the computer do precisely what you want, that is something very powerful.
It also makes the programs shorter and clearer to read.

\section{Redesign}
This enables the evolution of a program written in the language.
When source code can be reformatted and restructured easily without a lot of refactoring, it is easier to go from a rough prototype to a fully featured program.

\section{External Factors and Implementability}
These play a big role in the adaptation of a language.
Without some use for the language, it might as well not exist.
Having a platform for the language plays a major part in the way it will be adopted as a standard.
This does not have to be a physical platform, like UNIX or Windows.
It can be a virtual platform, like an already existing major library.
The only problem with the latter is, that the new language has to compete with other languages who already implement the library.

\bigskip

Do keep in mind that most of these criteria can be subjective to the user of the language and are not 100\% verifiable.
Thus we will try to discuss the most objective parts for sake of the verifiability.
