\chapter{MC in detail}
Here we will look at MC and learn what the language is and how it works.
\textbf{FIX THIS SENTENCE:}
Because the current version of MC is not documented, the following information comes from interviews with the research team.

\section{What is MC}
MC stands for MetaCasanova and is a declaritive functional language.
It tries to be a completely pure language, which means no side-effects are allowed directly.

MC can use .
The exception to this rule is the .NET functionality.
\textbf{.NET ALLOWS MANIPULATIVES, EXPAND}


\section{Goal}
\textbf{DOUBLE CHECK}
The goal of MC is to use higher order types with type safety, in a natural way of programming.
These higher order types gives the ability to resolve certain computations on compile time, which can normally be resolved at run time only.
This can substantially increase performance at run time.

It also supports the .NET library natively.
Because .NET allows for manipulation of values, MC supports this when using .NET.

MC also aims to be as flexible as possible with the safety of a strong type system.


\section{Basics}
We will now go through the basics of MC.
What systems MC uses, learn how the syntax works and use small code samples to explain the workings.

The evolution of these basics will be given in part~\ref{part:mcexpanded}.
This will give us a better understanding of why and how MC evolved.


\subsection{Terms, types \& kinds}\label{sec:basiclevels}
With MC you program on three different levels:
\begin{enumerate}[noitemsep]
   \item Terms
   \item Types
   \item Kinds
\end{enumerate}
Terms are the values of variables, like 5, 'c' or "Hello".
Types are the types of variables, like Integer, String or Boolean.
Kinds are for types, what types are to terms.
You could say the kinds are the types of the types.

\subsection{Runtime and compile time}
Kinds are resolved or inlined at compile time.
Types are also resolved or inlined, except when they create datastructures.
These data structures keep existing on runtime.

The syntax reflects this in the arrows used with the functions.
The \verb\=>\ arrow indicates a function operates on compile time and the \verb\->\ arrow indicates a function operates on runtime.


\subsection{Func}\label{sec:basicfunc}
First we need to declare a function before defining it.
For this we use the keyword \verb|Func|.

\begin{lstlisting}
Func "computeNumber" -> Boolean -> Int -> Int -> Int
\end{lstlisting}

Here we see that the function \emph{computeNumber} is a function which goes from a Boolean and two Interegers to an Integer.

The parameters are seperated by the \verb|->|.
The last parameter is the return type of the function and all the parameters between the name and the return type, are the arguments of the function.

A function is defined by one or multiple \emph{rules}.
A \emph{rule} consists of a \emph{conclusion} and one or more \emph{premises}.
They are separated by the \emph{bar}.
The conclusionstands underneath the bar and the premises above.

Now let's define a rule for \verb\computeNumber\.

\begin{lstlisting}[xleftmargin=5.0ex,numberstyle=\tiny\color{gray},numbers=left]
a == True
add b c -> res
---------------
computeNumber a b c -> res
\end{lstlisting}

The conclusion is on the fourth line, the bar on the third and the premise on the first and second.
The conclusion has the name of the function and the input arguments on the left of the arrow and the output argument on the right.
This syntax is similiar to that of natural deduction~\cite{}.

\subsubsection{Local defined variables}
The variables named in the conclusion of a function are locally defined.
With the function \verb\computeNumber\ the variables \verb\a\, \verb\b\ and \verb\c\ are examples of these local variables.


\subsection{Multiple rules}
There can also be multiple rules which form function definition.

\begin{lstlisting}
a == True
add b c -> res
---------------
computeNumber a b c -> res

a == False
mul b c -> res
---------------
computeNumber a b c -> res
\end{lstlisting}

When this happens the rules are attempted in order of definition.
If the above rule fails and the rule beneath it is attempted.
A rule fails when the arguments do not match.
If none of the rules match the program fails.

Let us go through this process with an example.

First we will try the following function call:
\begin{lstlisting}
computeNumber False 5 3 -> newValue
\end{lstlisting}

The first rule to be attempted is the one written first in the source code, so:
\begin{lstlisting}
a == True
add b c -> res
---------------
computeNumber a b c -> res
\end{lstlisting}

This rule will fail, because the first argument has the value \verb\False\ and not \verb\True\.
So this rule will not be executed.

The next rule to be attempted is:
\begin{lstlisting}
a == False
mul b c -> res
---------------
computeNumber a b c -> res
\end{lstlisting}
The first argument is set to \verb\False\ and the second and third are both Integers, so the rule matches.
The rule will be executed and the result will be put in \verb|newValue|.


\subsection{Constants}
Constants can be created by using \verb\Func\ without any parameters.
The return type still has to be declared.

\begin{lstlisting}
Func "bar" -> Int
bar -> 5
\end{lstlisting}

Here the constant \verb\bar\ is set to the value \verb\5\.

\bigskip

As we have seen \verb|Func| uses types in its declaration and terms in its definition.
The types enables the detection of wrong function calls during compile time.

Important to note is that functions declared by \verb\Func\ are on runtime.
As we will see in section~\ref{sec:basictypefunc}, MC also has the ability to declare and define functions on compile time.

\subsection{Functions as parameters}
Aside from variables, functions can also be given as parameters.
This needs to be specified in the declaration of the function.

\begin{lstlisting}
Func "isThisEven" -> ( 'a -> 'b ) -> 'a -> 'd
\end{lstlisting}

Here we see that the first argument \verb\( 'a -> 'b )\ is a function.
This is can be seen when we declare a function which takes one argument.

\begin{lstlisting}
Func "x" -> 'a -> 'b
\end{lstlisting}

When we strip away the name of the function and the keyword \verb\Func\, we are left with just the function.

\begin{lstlisting}
'a -> 'b
\end{lstlisting}

This we can use in declarations to indicate a function is used as the argument.


\subsection{Data}\label{sec:basicdata}
With \verb|Data| we can declare a constructor and deconstructors for a new type.
Effectively making it an alias.

Say that we want to create a union, a type which can be any of the predefined types within a set~\cite{}.
For this we need a way to construct the union type and a way to deconstructed the union back to its original type.
The deconstructor is needed to get know which of the types inside the union is actually used.
Only then can we know which of the types inside the inion is used.

As an example we will create a union of a String and a Float.
\begin{lstlisting}
Data "Left"  -> String -> String | Float
Data "Right" -> Float  -> String | Float
\end{lstlisting}

Here we create two constructors whom both go to the same type, \verb\String | Float\.
\verb\Left\ and \verb\Right\ can be seen as an alias for the \verb\String | Float\ union.

Let us see how this is used.
We need a function which takes a union as argument.

\begin{lstlisting}
Func "isFloat" -> ( String | Float ) -> Boolean
\end{lstlisting}

The parentheses in the declaration can be left out, but are used to clarify that the union is one argument.

In the definition we want to check which type the union is.
This can be done directly in the conclusion of a rule.

\begin{lstlisting}
isFloat Float -> True
\end{lstlisting}

The deconstructor of the argument given, automatically checks if the types match.
This can be done because they are aliases.
Aliases are automatically resolved to their basic types by the compiler.

Conditionals using aliases can be put in the conclusion.
Other conditionals have to be put in the premises, because they need to be computed.
As can be seen in section~\ref{sec:basicfunc}.

To make the definition of \verb\IsFloat\ complete we also need a rule that checks for \verb\String\.

\begin{lstlisting}
isFloat String -> False
\end{lstlisting}

Now we will test the function \verb\isFloat\ with the help of constant \verb\iAmFloat\.

\begin{lstlisting}
Right 9.27 -> iAmFloat
\end{lstlisting}

\verb\iAmFloat\ has type \verb\String | Float\ and can now be passed to \verb\isFloat\.

\begin{lstlisting}
isFloat iAmFloat -> output
\end{lstlisting}

When \verb\iAmFloat\ is deconstructed to its original type it will match with the first rule of \verb\isFloat\.
The variable \verb\output\ now contains the value \verb\True\.


\subsection{TypeAlias}
Because the \verb\|\ (\emph{pipe}) operator, used in section~\ref{sec:basicdata}, is not built in the language we need to create it.
To do this we need to manipulate types.

We have already seen that \verb\TypeFunc\ can do this, see section~\ref{sec:basictypefunc}.
But to make \verb\|\ work, we now need a constructor and deconstructor that works with kinds.

\verb\TypeAlias\ is the same as \verb\Data\ only on a higher level of abstraction.
It constructs and deconstructs kinds.

With \verb\TypeAlias\ we can create a generic \verb\|\ with which we can create unions.
Unlike \verb\Data\, \verb\TypeAlias\ needs both a declaration and a definition.
The declaration shows what happens on kind level and the definition shows what happens on type level.


\begin{lstlisting}
TypeAlias Type => "|" => Type => Type
\end{lstlisting}

Here we see how the generic \verb\|\ is declared.
It takes two paramaters of any type and returns a type.

The \verb\Type\ is a kind and indicates an unknown type is used.

As shown parameters can be infix.

\subsubsection{Infix parameters}
There is a limitation to the use left arguments, there may only be one.
This is because of the parser used.
The parser would become overly complex when adding multiple arguments on the left.

Because the benefits of having multiple arguments in front of the function name do not outway the time it consumes to expand the parser, the choice was made to only allow one argument in front.

\bigskip

When defining \verb\|\ we want to use generic types.
This way a union can be created from all types.

\subsubsection{Generic type identifiers}\label{sec:basictypeidentifiers}
To indicate generic types the \verb\'\ notation is used.

This is enhanced with the use of \emph{identifiers} after \verb\'\.
These give the generic type a name and can be used to express if one generic type is the same as another generic type.

We will use this in the definition of \verb\|\:

\begin{lstlisting}
'a | 'b => pipe<'a 'b>
\end{lstlisting}

Now we can say that two different types are used as the arguments and in the created pipe.

\subsubsection{Type annotiatons}\label{sec:basictypeannotations}
The angle brackets are used as type annotation for \verb\pipe\.
They indicate that \verb\'a\ and \verb\'b\ are part of the type \verb\pipe\.
This is only used with generic types, because it makes it easier for the parser to resolve the types.
More on this in section~\ref{sec:syntaxtypeannotations}.


\subsection{TypeFunc}\label{sec:basictypefunc}
\verb|TypeFunc| creates a function on type level.
It can do computations with both types and terms.

We will demonstrate the power of \verb\TypeFunc\ with a function which manipulates a type.
The function will take a tuple and return the same tuple, but with switched types.

First we need to declare a tuple with \verb\TypeAlias\.

\begin{lstlisting}
TypeAlias Type => "*" => Type => Type
'a * 'b => tuple<'a 'b>
\end{lstlisting}

Now that we have a tuple we can use it in the function declaration.
The tuple argument will have generic types so it can work with any tuple.

\begin{lstlisting}
TypeFunc "switch" => tuple<'a 'b> => tuple<'b 'a>
\end{lstlisting}

Next we have the definition.
Here we need to deconstruct the tuple to its original arguments.
These arguments can then be used to create the return tuple.

\begin{lstlisting}
a => (c * d)
(d * c) => res
---------------
switch a => res
\end{lstlisting}

Here we can see how the types inside the tuple are switched and returned as a new tuple.

\subsubsection{Parameters}
Important to note is that both \verb\TypeAlias\ and \verb\TypeFunc\ can use kinds, types and terms.
Because they work on compile time only, they cannot replace \verb\Data\ and \verb\Func\.

\verb\Data\ and \verb\Func\ exist for explicit runtime functions.


\subsection{Module}
\verb|Module| is used to create a container on compile time.
It is a collection of function declarations and definitions.

It does not fit within the levels defined in section~\ref{sec:basiclevels}.
Modules can only be declared by \verb\TypeFunc\.

Say we want to create a container for every type which does an addition of two variables of those types.
The could be declared when we need them or we can put them in a \verb\Module\.

When we create an addition container using a module, we do not have to type out the addition functions for every type.
We can just call the module to create the functions for us.

A \verb\Module\ is declared with a \verb\TypeFunc\.
\begin{lstlisting}
TypeFunc "Add" => Type => Module
\end{lstlisting}

Here we declare the \verb\Add\ to take a type and return a \verb\Module\.

We then want to define the module \verb\Add\ with the \verb\+\ operator and the \verb\identityAdd\ constant.

\begin{lstlisting}
Add 'a => Module {
  Func 'a -> "+" -> 'a -> 'a
  Func "identityAdd" -> 'a
}
\end{lstlisting}

This creates a basic container with generic addition functionality.

As shown it can contain \verb|Func|, but can also contain \verb|Data|, \verb|TypeFunc|, \verb|TypeAlias| and another \verb|Module|.

The declarations within the Module do not have to be defined.
This way we can define different behavior for every instance of the module.

It is possible to have a function declared and defined within a module.

When we want to define the above declared \verb|Add| with an integer, we instanciate the module with \verb\Int\.
We then define the functions which are declared within \verb\Add\ to finish the module.

\begin{lstlisting}
MonoidAdd Int = {
  Int -> "+" -> Int -> Int
  identityAdd -> 0
}
\end{lstlisting}

The \verb|Func|s are defined as they normally are, only now they are wrapped within a \verb|Module|.


\subsubsection{The caret}
When we want to call a function within a module from outside the module the \verb\^\ is used.

\begin{lstlisting}
Func "caretTest" -> Int
caretTest -> identityAdd^Int
\end{lstlisting}

This creates a constant named \verb\caretTest\ with the same value as the \verb\identityAdd\ from the module \verb\Int\.
The \verb\^\ can be seen as the `\verb\.\' (the dot) used in C\#.
The hierarchy used in MC is different from most languages.

Say we have a C\# class \verb\Int\ containing the constant \verb\identityAdd\, the constant is called like this:
\begin{lstlisting}
Int.identityAdd
\end{lstlisting}

As seen in the example MC does it the other way around.
This has the advantage of knowing immediately what you are using, instead of knowing where it comes from.


\subsubsection{Inherit}
Modules can also inherit from other modules.
This is done with \verb\inherit\.

We will create a module which inherits from the \verb\Add\ module.
The operator \verb\-\ will then be added aswell.

\begin{lstlisting}
TypeFunc "GroupAdd" => Type => Module
GroupAdd 'a => Module {
  inherit Add 'a
  Func 'a -> "-" -> 'a -> 'a
}
\end{lstlisting}

The module \verb\Add\ from section~\ref{sec:basicmodule} is instantiated with \verb\'a\.
The created \verb\Add\ module is then inherited into \verb\GroupAdd\.

The function declarations and definitions of the inherited module are directly usable within the new module.

If a module takes another module as an argument, the module can also directly inherit.

\begin{lstlisting}
TypeFunc "GroupAdd" => Add => Module
GroupAdd M => Module {
  inherit M
}
\end{lstlisting}

Now everything from module \verb\M\ is inherited into \verb\GroupAdd\.

When inheriting a module which contains an inherit, these are also inherited in to the current module.
This works recursively.


\subsection{priority}
We can also give a priority together with a declaration.
The priority tells which function to execute first.

The priority is indicated by the \verb\#>\ and is placed after the declaration.
When we look at \verb\Data\ it will look like this:

\begin{lstlisting}
Data "Left"  -> String -> String | Float  #> 7
Data "Right" -> Float  -> String | Float  #> 5
\end{lstlisting}

And with \verb\Func\ and \verb\TypeFunc\ it is used like this:
\begin{lstlisting}
Func "bar" -> Int #> 12
TypeFunc "foo" => Float => 'a => 'b #> 9
\end{lstlisting}

The \verb\#>\ is also used to indicate associativity.
Everything is left associative by default, but if we want to make it right associative we can do that by placing an \verb\R\ after the \verb\#>\.

\begin{lstlisting}
Func Int -> "\" -> Int -> Int #> R
\end{lstlisting}

The priority and associativity can also be used in combination with each other.

\begin{lstlisting}
Func Int -> "\" -> Int -> Int #> 25 R
\end{lstlisting}


\subsection{Import}
\verb\Import\ is used when importing other files in the current file.

If the file imported has any imports, they are ignored.
Unlike \verb\inherit\, \verb\import\ is not recursive.

The programmer can directly use the declarations and definitions used in the imported file.
When the programmer wants to explicitely specify to use a function from the imported file the \verb|^| is used.

We will import the file ``vector'' and use the \verb\Vector2\ type from it.

\begin{lstlisting}
import vector

Func "location" -> Vector2
location -> createVector2^vector 8.9 19.0
\end{lstlisting}

The importing of MC files always works with non capitalized import statements, even when the actual files does contains capitals.
This is done to differentiate between MC imports and .NET imports.

The order of elments is the same as with modules, only when using .NET imports there is a difference in syntax.
When calling a .NET function the elements are in the same order as with .NET, instead of doing it the other way around when using the \verb\^\ with modules.

\begin{lstlisting}
import System

Func "dotNetTest" -> String
dotNetTest -> DateTime^Now^ToString()
\end{lstlisting}

Here \verb\dotNetTest\ becomes a String which contains the current date and time.

In keeping constistency with the .NET way of calling, the programmer does not have to reverse the order of the elements in the call.
This might seem like a trivial thing to do, but from experiments we concluded that it confused the programmer more than initially thought.
For this reason the order of elements in a .NET call will stay in synchonicity with the .NET standard.


\subsection{Builtin}
Some things cannot be created out of nothing and need to be built in the compiler.
An example of this is boolean.

When using such a builtin literal the keyword \verb\builtin\ is used.
We can now correctly implement the function \verb\foo\ from section~\ref{sec:basicfunc} using the \verb\builtin\ keyword:

\begin{lstlisting}
add b c -> res
---------------
foo True^builtin b c -> res

mul b c -> res
---------------
foo False^builtin b c -> res
\end{lstlisting}

It can be seen as if they are imported

\subsection{Comments}
There are two sorts of comments in MC: a single line comment, indicated by \verb\$$\, and a block comment, indicated by \verb\$* *$\.
With these two options the programmer can sufficiently insert comments in the code.


\subsection{Lambdas}
MC also has a fully implemented lambdas.

The basic syntax is as one would expect of a lambda, it has arguments and returns what the functionBody returns

\begin{lstlisting}
(\ arguments -> functionBody )
\end{lstlisting}

In practice this would look like:

\begin{lstlisting}
(\ a -> divide^Int 10 a )
\end{lstlisting}

Lambdas do not need to be declared because they always are generic functions.
The typechecker will check the lambdas the same way as any other generic function.
From the context of what the function body does together with the types of the arguments, it can deduce what the output type should be.


\subsection{ArrowFunc}\label{sec:basicmcarrowfunc}
\verb\ArrowFunc\ always needs an argument on the left of the name and atleast one function to the right.
A unique feature of \verb\ArrowFunc\ is the two syntax options it has when the function gets called.

The first is like a normal function and the second converts it to a lambda.

As with \verb\Func\ it needs a declaration and a definition.

\begin{lstlisting}
ArrowFunc Int -> ":~>" -> (Int -> Int) -> Int
f a -> res
-------------
a :~> f -> res
\end{lstlisting}

Here \verb\:~>\ takes an integer and a function that takes an integer and returns an integer.

The declaration and definition are the same as the rest of MC.

When we call \verb\:~>\, there is the normal way:

\begin{lstlisting}
a :~> f -> res
\end{lstlisting}

And there is the second way of calling:

\begin{lstlisting}
{a :~> out
  f out} -> res
\end{lstlisting}

The brackets are used to indicate everything inside it belongs together.
When an \verb\ArrowFunc\ is called like this it gets converted to a lambda.
The first argument is then used a the argument for that lambda.

\begin{lstlisting}
(\ out -> f out ) a -> res
\end{lstlisting}

The result from this is then returned as the output in \verb\res\.

This syntax exists for when the nesting of lambdas occur.
Lambdas become unreadable when nested.

\begin{lstlisting}
(\ b -> (\ c -> f c ) b ) a -> res
\end{lstlisting}

When using the \verb\ArrowFunc\ syntax it nests neatly.

\begin{lstlisting}
{a :~> b
  {b :~> c
    f c}} -> res
\end{lstlisting}

This syntax stems from the use of the bind of monads, which will be explained in further detail in section~\ref{sec:standardmonad}.


\subsection{Partial application}
Lastly MC supports partial application.
This means that you do not have to give all the arguments to a function.
When this is done a closure is created and given as output.

We will create a closure with the function \verb\add\.
\verb\add\ takes two Integers and returns an Integer.

In the definition we will say the two arguments will be added together.
\begin{lstlisting}
Func "add" -> Int -> Int -> Int

a + b -> res
--------------
add a b -> res
\end{lstlisting}

Now we will give only one argument to \verb\add\ and create a new function \verb\addThree\.

\begin{lstlisting}
add 3 -> addThree
\end{lstlisting}

With this construct we have created the partially applied function \verb\addThree\.
When we look what it contains we see that it has a closure with a partly implemented \verb\add\.

\begin{lstlisting}
3 + b -> res
--------------
add 3 b -> res
\end{lstlisting}

We can now give \verb\addThree\ its second argument to complete the closure.
This can be done multiple times.

\begin{lstlisting}
addThree 6 -> foo

addThree 7 -> bar
\end{lstlisting}

The variable \verb\foo\ has a value of \verb\9\ and \verb\bar\ has a value of \verb\10\.

When type annotations are used there can be no partial application.
The type annotations need to know what types it gets or they will fail.
This is further explained in section~\label{sec:syntaxtypeannotations}.

\bigskip

Now that we know the basics of MC lets take a look at the syntax has evolved.
